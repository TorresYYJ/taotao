项目总结：
淘淘商城是采用分布式架构部署的一个大型网上商城系统，类似于京东商城。本系统分前台系统和后台系统。前台系统主要负责商城的页面的显示功能，这里采用的面向服务的方式，pc端手机端只负责显示页面，业务逻辑都在服务层实现，客户端调用服务端接口来实现显示功能。

在前台系统中主要分为：客户端：系统前台页面显示系统（portal，8082）。服务端系统：（1）rest系统（8081）：负责调用CMS系统的内容，将CMS系统的内容显示到页面，（这里的CMS内容管理系统，在后台实现）。（2）商品的搜索系统（8083），当在页面输入商品信息时，可以搜索商品。这里用到了solr技术，利用solr索引库来实现。（3）SSO(单点登陆系统，8084)，因为商城采用分布式的系统部署，将整个系统划分为几个子系统，所以对于用户的访问权限是一个问题，如何实现一次登陆即其他系统都可以免登陆，sso可以解决。（4）订单系统（8085）：商城购物少不了订单系统，所以将此作为一个独立工程编写。

后台系统功能：商城的后台系统主要是负责商品的分类，添加、规格参数。CMS系统（这里主要是广告的分类、添加）。

本系统前台界面设计采用的easyUI的设计，后台采用springMVC、spring、mybatis框架，擦用java语言编程。

步骤分析：

一、项目需求分析：模仿京东商城系统。

二、项目数据库设计：商品信息表、商品信息分类表、商品信息描述表、商品规格参数表、

CMS系统内容表、CMS系统内容分类表

用户表、订单表、订单的具体明细表

三、具体实现：

1、框架的搭建：

       这里采用maven来管理整个项目。优势两点：1、maven可以以管理整个项目工程，方便热部署项目，项目发布方便。2、maven管理你jar包具有很大的优势，可以自动下载所需的jar包，只需定义好版本即可，其他maven自动下载。

因为这个项目比较大，子工程比较多，所以我们建立一个pom类型（聚合工程）parent来管理里所有jar包的版本，这样其他 子工程都依赖此工程。版本得到了统一，不会出现因版本问题导致的错误。其次建立一个专门的（jar类型）common工具类，可以将系统中使用到的工具类都加入此类，其他类也依赖此类，就可以使用这里面的工具了。此工具类也依赖parent类。

下面就是利用SSM框架来搭建工程了：利用框架搭建工程主要分两步：框架所依赖的jar包，框架的配置文件。弄清了这两点就好办了。框架主要分三层：dao层（mybatis）（主要是与数据库打交道）、service层（spring）（主要是负责调用dao层，实现业务逻辑的编写）、controller层（springMVC）（这里主要调用service层，根据jsp页面的内容，将jsp的内容传递到service层，然后讲数据显示到jsp页面）。所以这里的配置文件也就：mybatis的SqlMapConfig.xml （主要是它的插件配置，数据库配置放在dao）。spring将mybatis和springMVC整合起来的application_context_dao.xml（配置数据源，与数据库的连接），application_context_service.xml（将service的文件包引入工程）。application_context_transation.xml（这里将事务独立出来，主要是事务的配置）

SpringMVC.xml（主要是前端控制器，试图解析器的配置）

框架搭建完成后，利用mybatis的逆向工程生成各个表的mapper.xml和mapper.java文件、pojo文件。

2、具体的功能的实现逻辑

（1）后台系统功能实现

（这里主要讲商品的查询、添加、规格参数、CMS系统的分类、添加）

其实对于功能模块的分析主要有三点：

从哪个数据表获取（主要mapper实现）；页面传递是否有参数，页面的url是什么（controller实现）；返回值是什么（即页面展示的格式是什么样子的，这个根据jsp使用的框架来决定，比如这里的easyUI，可以查询它的api文档，找到其返回值类型）；

A、商品的查询逻辑分析：其实对于商品的查询主要就是从数据库中将所有商品查询出来。这简单的查询很简单，可是在页面分页显示出来这就是一个问题了。这里到了mybatis的分页插件pageHelper来实现。

传入参数：Easyui页面默认有page、rows参数传递。

返回值：easyui的格式即datagrid的格式，专门编写一个对应的pojo类放入专门工具类中使用，返回格式即这个pojo。

逻辑：Dao层：Dao层用mybatis的逆向工程

Service调用mapper的查询和分页实现逻辑。

Controller即将参数传递过去，url写好

B、商品添加：商品添加即将商品信息写入数据库，页面传递的内容当点击提交按钮时直接写入数据库，只需补全没有的字段即可。

这里涉及到商品的类目选择、上面的图片上传、商品的描述信息。

类目选择首先得将类目展示出来，这里使用的异步树的格式。查询api发现异步树的返回值的格式。主要思路是：根据parentId来查询类目表，默认从0开始，异步树有个特点，就是每次获取到的id，如果有子节点，会发送url再次请求，如果没有子节点则不发送请求，所以可以都遍历到所有节点。（这个是tree的特点，自动请求）

异步树的特点：从最顶层开始读取，先读顶层节点，如果是闭合状态，发送请求给服务器读取子节点，子节点的状态依赖于父节点，当展开一个封闭的节点时，如果节点没有加载子节点，它将会把节点的id的值作为http请求参数并命名为id，通过url发送到服务器上检索子节点。所以遍历一次后，如果父节点还是父节点（即存在子节点）则检索下面的子节点的内容，将子节点的id作为parentId来检索下面的节点。如果不是父节点了，则打开下面列表。也就是说这些实现都是 异步树自动实现的，我们只需要判断父节点的状态即可，下面的检索根据这个状态进行。

图片上传功能：因为商城的图片非常多，所以我们将这么多的图片保存在图片服务器中，然后将图片在服务器中的具体url写入数据库，供前台调用。前台获取到这个url既可获取到这个图片。这里图片上传到服务器的功能：先生存图片的名称，然后生成图片保存的格式，然后利用ftpUtil将图片上传到服务器，返回一个url链接。

商品规格参数，这里采用的规格参数模板的形式。：

这里有两个表：一个模板表（根据商品的分类建立的模板，根据分类id），一个展示模板表（根据商品的信息写入模板表，根据商品id查询商品信息，然后写入对应订单模板中，然后生成HTML）。

商品的描述：这里采用文本的形式存储的，写入即可。富文本编辑器。

CMS分类：这里的格式也是用了异步树的格式，所以显示方法是一样的。

分类添加：像表中插入数据库即可。

（2）前台功能实现

首页大广告位的实现：这里是从CMS系统中获取广告位的图片，然后展示在页面。但是前台跟后台是不一样的端口，如何从前台访问后台呢，可以使用jsonp的形式。但是我们这里系统是采用面向服务的编程，所以采用rest接口的方式然后功能前台调用，这里用的httpcliet来调用接口。

商品搜索功能的实现：

首先在linux下部署好solr服务器，然后将数据库的表字段导入到solr索引库。然后编写search服务接口，然后供前台调用这个服务接口。

Rest功能：

商品详情页面展示：写三个服务：根据id查询商品的具体信息显示到页面，根据id查询商品的内容表，根据id查询商品的规格参数，即将三个信息展示到页面。然后前台分别调用。

SSO系统：这里涉及到拦截器。

       这里是利用了sso的接口文档，即校验接口、注册、登录接口、根据token查询用户接口、安全退出接口。

   这个的调用服务层是利用jsonp的形式访问的服务接口，实现跨域访问。客户端全部在jsp页面实现的。

具体流程：

     当用户点击注册的时候，跳转到注册页面，即用户信息的保存功能。检验用户名是否存在、手机号和邮箱不能为空。

       当用户点击登录按钮的时候，用户输入用户名和密码，检验用户名是否在数据库中存在，然后用户名密码是否正确。这里的密码是用了spring的MD5加密技术。当全部成功后，给用户颁发一个token令牌（利用uuid实现），然后将token存入到redis中（token的key是它生成的号，值是用户的名字），然后设置在redis的过期时间。这相当于用户的session。

   然后将token写入cookie中，前台页面利用jsonp调用，根据cookie中的token的值，调用sso的根据token查询用户的服务，查看用户是否有效，如果有效则将用户返回前台页面，前台页面获取用户的用户名显示在首页，表示***已登陆。

   这里的cookie是设置了共享域，即全部子系统都可以访问到cookie。

当用户登录其他子系统时，先从从cookie中获取token信息，根据token信息获取用户信息，判断用户信息是否有效，如果有效则放行，如果无效，则利用拦截器拦截跳转到登录页面。用户再次登录的时候刷新redis的时间，重新设置有效期。

拦截器的拦截，在springMVC.xml中设置拦截的名称。

购物车功能：

购物车功能注意到这里商品加入购物车，是将购物车保存在cookie中。这里用到cookieUtil工具来实现这些保存删除功能。在商品详情页面点击“加入购物车”按钮提交一个请求吧商品id传递给Controller，Controller接收id，Controller调用Service根据商品id查询商品基本信息，购物车的商品专门写一个pojo对象，因为商品的很多信息购物车里面用不到。将购物车的商品的pojo，把商品写入cookie中，加入cookie之前先从cookie中把购物车的商品取出来判断当前购物车商品列表中是否有此商品，如果有数量加一，如果没有添加一个商品，数量为1。展示给用户购物车列表。

 

订单系统：订单系统主要是订单的创建、查询、修改、删除功能。

功能：接收三个参数，

1、对应订单表的pojo。

2、订单明细表对应的商品列表。每个元素是订单明细表对应的pojo

3、物流表对应的pojo
